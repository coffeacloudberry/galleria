const paths = require("./paths");
const fs = require("fs");
const { git } = require("./utils");

class StoriesPlugin {
    constructor() {
        this.rootDir = paths.build;
        this.pathAllPhotos = `${this.rootDir}/content/photos`;
        this.pathAllStories = `${this.rootDir}/content/stories`;
        this.autoGeneratedDirName = `rev_${git("describe --always")}`;
        this.storyMetadata = {};

        // cache to reduce the amount of file accesses
        this.geodataPerStory = {};
        this.allPhotos = [];
        this.allStories = [];
    }

    getAllPhotos() {
        if (this.allPhotos.length === 0) {
            this.allPhotos = fs.readdirSync(this.pathAllPhotos);
            this.allPhotos.sort();
        }
        return this.allPhotos;
    }

    getAllStories() {
        if (this.allStories.length === 0) {
            this.allStories = fs.readdirSync(this.pathAllStories);
        }
        return this.allStories;
    }

    readInfoFile(folderType, docId) {
        const photoDir = `${this.rootDir}/content/${folderType}/${docId}`;
        return JSON.parse(fs.readFileSync(`${photoDir}/i.json`).toString());
    }

    /**
     * Prints an error if the story contains a GPX file but no Webtrack.
     * Prints a warning if the story contains a Webtrack file but no GPX.
     * Prints an info if the story does not contain Webtrack/GPX.
     * Return true if the story contains a webtrack.
     */
    storyContainsWebtrack(storyId) {
        const file = `${this.pathAllStories}/${storyId}/${storyId}.`;
        const gpxFile = `${file}gpx`;
        const hasGpx = fs.existsSync(gpxFile);
        const webtrackFile = `${file}webtrack`;
        const hasWebtrack = fs.existsSync(webtrackFile);
        if (!hasWebtrack && !hasGpx) {
            console.info(`Missing both ${webtrackFile} and ${gpxFile}`);
        } else if (hasWebtrack && !hasGpx) {
            console.warn(`Got ${webtrackFile} without ${gpxFile}`);
        } else if (hasGpx && !hasWebtrack) {
            console.error(`Got ${gpxFile} without ${webtrackFile}`);
        }
        return hasWebtrack;
    }

    writeInfoFile(docFolder, contentObject) {
        // delete old directories
        fs.readdirSync(docFolder)
            .filter(
                (dirName) =>
                    dirName.startsWith("rev_") &&
                    dirName !== this.autoGeneratedDirName,
            )
            .forEach((oldDir) =>
                fs.rmSync(`${docFolder}/${oldDir}`, { recursive: true }),
            );

        // create the new one and put the file into it
        const genDir = `${docFolder}/${this.autoGeneratedDirName}`;
        if (!fs.existsSync(genDir)) {
            fs.mkdirSync(genDir);
        }
        fs.writeFileSync(`${genDir}/i.json`, JSON.stringify(contentObject));
    }

    /**
     * Sort two stories based on the start time. The most recent one will be
     * the first in the list. A story without start time will be at the end.
     * @param firstEl One story.
     * @param secondEl An other story.
     */
    static sortTwoStories(firstEl, secondEl) {
        if (firstEl.metadata === null || secondEl.metadata === null) {
            return 0;
        }
        if (typeof firstEl.metadata.start === "undefined") {
            return typeof secondEl.metadata.start === "undefined" ? 0 : 1;
        }
        if (typeof secondEl.metadata.start === "undefined") {
            return -1;
        }
        return firstEl.metadata.start < secondEl.metadata.start ? 1 : -1;
    }

    /** Add geodata state to a story if needed. */
    addGeodataState(storyId) {
        if (this.geodataPerStory[storyId] === undefined) {
            this.geodataPerStory[storyId] = this.storyContainsWebtrack(storyId);
        }
    }

    /** Metadata needed in the list of stories. */
    static essentialStoryMetadata(storyId, metadata) {
        if (metadata.mostRecentPhoto) {
            return {
                id: storyId,
                metadata: {
                    duration: metadata.duration,
                    season: metadata.season,
                    start: metadata.start,
                    totalPhotos: metadata.totalPhotos,
                    mostRecentPhoto: metadata.mostRecentPhoto,
                },
            };
        } else {
            return {
                id: storyId,
                metadata: {
                    duration: metadata.duration,
                    season: metadata.season,
                    start: metadata.start,
                    totalPhotos: metadata.totalPhotos,
                },
            };
        }
    }

    generatePhotoInfoFiles(genPhotos) {
        for (const photoId of this.getAllPhotos()) {
            const photoDir = `${this.pathAllPhotos}/${photoId}`;
            let PhotoData = genPhotos[photoId];
            if (PhotoData.story) {
                PhotoData = {
                    ...PhotoData,
                    photosInStory:
                        this.storyMetadata[PhotoData.story].totalPhotos,
                };
            }
            this.writeInfoFile(photoDir, PhotoData);
        }
    }

    generateStoryInfoFile(storyId) {
        const storyDir = `${this.pathAllStories}/${storyId}`;
        this.writeInfoFile(storyDir, this.storyMetadata[storyId]);
    }

    listStories() {
        const genPhotos = {};
        this.storyMetadata = {};
        try {
            let prevStory = "";
            let lastStory = null;
            for (const photoId of this.getAllPhotos()) {
                const id = parseInt(photoId, 10);
                const photoMetadata = this.readInfoFile("photos", photoId);
                const storyId = photoMetadata.story;
                if (storyId) {
                    const storyMetadata = this.readInfoFile("stories", storyId);
                    if (prevStory !== storyId) {
                        this.addGeodataState(storyId);
                        lastStory = {
                            ...storyMetadata,
                            hasGeodata: this.geodataPerStory[storyId],
                            totalPhotos: 1,
                            mostRecentPhoto: id,
                            geocodedPhotos: [],
                        };
                    } else if (lastStory) {
                        // update
                        lastStory.totalPhotos += 1;
                        lastStory.mostRecentPhoto = id;
                        if (typeof photoMetadata.position === "object") {
                            lastStory.geocodedPhotos.push({
                                id,
                                position: photoMetadata.position,
                            });
                        }
                    }
                    this.storyMetadata[storyId] = lastStory;
                    prevStory = storyId;
                    photoMetadata.storyPhotoIncrement = lastStory.totalPhotos;
                }
                genPhotos[photoId] = photoMetadata;
            }
            this.generatePhotoInfoFiles(genPhotos);

            for (const storyId of this.getAllStories()) {
                if (!this.storyMetadata[storyId]) {
                    // In case a story has no photo
                    this.addGeodataState(storyId);
                    this.storyMetadata[storyId] = {
                        ...this.readInfoFile("stories", storyId),
                        hasGeodata: this.geodataPerStory[storyId],
                        totalPhotos: 0,
                    };
                }
                this.generateStoryInfoFile(storyId);
            }

            const storyList = [];
            Object.entries(this.storyMetadata).map(([storyId, metadata]) => {
                storyList.push(
                    StoriesPlugin.essentialStoryMetadata(storyId, metadata),
                );
            });
            storyList.sort(StoriesPlugin.sortTwoStories);
            return storyList;
        } catch (err) {
            console.error(err);
            return [];
        }
    }

    apply(compiler) {
        const plugin = { name: this.constructor.name };

        compiler.hooks.compilation.tap(plugin, (compilation) => {
            compilation.hooks.additionalAssets.tapPromise(plugin, () => {
                return new Promise((resolve) => {
                    const out_str = JSON.stringify(this.listStories());

                    const source = {
                        source() {
                            return out_str;
                        },
                        size() {
                            return out_str.length;
                        },
                    };

                    if (compilation.emitAsset) {
                        compilation.emitAsset("all_stories.json", source);
                    } else {
                        // Remove this after drop support for webpack@4
                        compilation.assets["all_stories.json"] = source;
                    }

                    resolve(out_str);
                });
            });
        });
    }
}

module.exports = StoriesPlugin;

const paths = require("./paths");
const fs = require("fs");
const { git } = require("./utils");

class StoriesPlugin {
    constructor() {
        this.rootDir = paths.build;
        this.autoGeneratedDirName = `rev_${git("describe --always")}`;
    }

    getAllPhotos() {
        const allPhotos = fs.readdirSync(`${this.rootDir}/content/photos/`);
        allPhotos.sort();
        return allPhotos;
    }

    getAllStories() {
        return fs.readdirSync(`${this.rootDir}/content/stories/`);
    }

    readInfoFile(folderType, docId) {
        const photoDir = `${this.rootDir}/content/${folderType}/${docId}`;
        return JSON.parse(fs.readFileSync(`${photoDir}/i.json`).toString());
    }

    storyContainsWebtrack(storyId) {
        const webtrackDir = `${this.rootDir}/content/stories/${storyId}`;
        return fs.existsSync(`${webtrackDir}/t.webtrack`);
    }

    writeInfoFile(docFolder, contentObject) {
        // delete old directories
        fs.readdirSync(docFolder)
            .filter(
                (dirName) =>
                    dirName.startsWith("rev_") &&
                    dirName !== this.autoGeneratedDirName,
            )
            .forEach((oldDir) =>
                fs.rmSync(`${docFolder}/${oldDir}`, { recursive: true }),
            );

        // create the new one and put the file into it
        const genDir = `${docFolder}/${this.autoGeneratedDirName}`;
        if (!fs.existsSync(genDir)) {
            fs.mkdirSync(genDir);
        }
        fs.writeFileSync(`${genDir}/i.json`, JSON.stringify(contentObject));
    }

    /**
     * Sort two stories based on the start time. The most recent one will be
     * the first in the list. A story without start time will be at the end.
     * @param firstEl One story.
     * @param secondEl An other story.
     */
    static sortTwoStories(firstEl, secondEl) {
        if (firstEl.metadata === null || secondEl.metadata === null) {
            return 0;
        }
        if (typeof firstEl.metadata.start === "undefined") {
            return typeof secondEl.metadata.start === "undefined" ? 0 : 1;
        }
        if (typeof secondEl.metadata.start === "undefined") {
            return -1;
        }
        return firstEl.metadata.start < secondEl.metadata.start ? 1 : -1;
    }

    listStories() {
        const storiesWithPhoto = [];
        const photosInStories = {};
        const genPhotos = {};
        try {
            // create data structures
            const allPhotos = this.getAllPhotos();
            let prevStory = "";
            let lastStory = null;
            for (const photoId of allPhotos) {
                const id = parseInt(photoId, 10);
                const photoMetadata = this.readInfoFile("photos", photoId);
                const storyId = photoMetadata.story;
                if (storyId) {
                    const storyMetadata = this.readInfoFile("stories", storyId);
                    if (prevStory !== storyId) {
                        lastStory = {
                            id: storyId,
                            metadata: {
                                ...storyMetadata,
                                hasGeodata: this.storyContainsWebtrack(storyId),
                                totalPhotos: 1,
                                mostRecentPhoto: id,
                                geocodedPhotos: [],
                            },
                        };
                        storiesWithPhoto.push(lastStory);
                    } else if (lastStory) {
                        // update
                        lastStory.metadata.totalPhotos += 1;
                        lastStory.metadata.mostRecentPhoto = id;
                        if (typeof photoMetadata.position === "object") {
                            lastStory.metadata.geocodedPhotos.push({
                                id,
                                position: photoMetadata.position,
                            });
                        }
                    }
                    photosInStories[storyId] = lastStory.metadata;
                    prevStory = storyId;
                    photoMetadata.storyPhotoIncrement =
                        lastStory.metadata.totalPhotos;
                }
                genPhotos[photoId] = photoMetadata;
            }

            // generate photo info files
            for (const photoId of allPhotos) {
                const photoDir = `${this.rootDir}/content/photos/${photoId}`;
                let PhotoData = genPhotos[photoId];
                if (PhotoData.story) {
                    PhotoData = {
                        ...PhotoData,
                        photosInStory:
                            photosInStories[PhotoData.story].totalPhotos,
                    };
                }
                this.writeInfoFile(photoDir, PhotoData);
            }

            const combinedStories = storiesWithPhoto.map((entry) => {
                // keep only the essential
                return {
                    id: entry.id,
                    metadata: {
                        duration: entry.metadata.duration,
                        season: entry.metadata.season,
                        start: entry.metadata.start,
                        totalPhotos: entry.metadata.totalPhotos,
                        mostRecentPhoto: entry.metadata.mostRecentPhoto,
                    },
                };
            });

            // generate story info files
            const allStories = this.getAllStories();
            for (const storyId of allStories) {
                const storyDir = `${this.rootDir}/content/stories/${storyId}`;
                let contentObject = photosInStories[storyId];
                if (!contentObject) {
                    // In case a story has no photo
                    contentObject = this.readInfoFile("stories", storyId);
                    combinedStories.push({
                        id: storyId,
                        metadata: {
                            duration: contentObject.duration,
                            season: contentObject.season,
                            start: contentObject.start,
                            totalPhotos: 0,
                        },
                    });
                }
                this.writeInfoFile(storyDir, contentObject);
            }

            // skipcq: JS-0387
            combinedStories.sort(StoriesPlugin.sortTwoStories);
            return combinedStories;
        } catch (err) {
            console.error(err);
            return [];
        }
    }

    apply(compiler) {
        const plugin = { name: this.constructor.name };

        compiler.hooks.compilation.tap(plugin, (compilation) => {
            compilation.hooks.additionalAssets.tapPromise(plugin, () => {
                return new Promise((resolve) => {
                    const out_str = JSON.stringify(this.listStories());

                    const source = {
                        source() {
                            return out_str;
                        },
                        size() {
                            return out_str.length;
                        },
                    };

                    if (compilation.emitAsset) {
                        compilation.emitAsset("all_stories.json", source);
                    } else {
                        // Remove this after drop support for webpack@4
                        compilation.assets["all_stories.json"] = source;
                    }

                    resolve(out_str);
                });
            });
        });
    }
}

module.exports = StoriesPlugin;

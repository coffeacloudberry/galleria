import m from "mithril";
import snarkdown from "snarkdown";

import { config } from "../config";
import CustomLogging from "../CustomLogging";
import { t } from "../translate";
import { PhotoInfo, PhotoPosition } from "./Photo";

const error = new CustomLogging("error");

export interface EasyDate {
    day: number;
    month: number;
    year: number;
}

enum Season {
    winter,
    spring,
    summer,
    autumn,
}

export type SeasonStrings = keyof typeof Season;

export enum MapTheme {
    default,
    darkSnow,
    whiteSnow,
}

export type MapThemeStrings = keyof typeof MapTheme;

export type GeocodedPhoto = { id: number; position: PhotoPosition };

/** GPS model and configuration */
export interface GpsConfig {
    /**
     * Example: 'Garmin 64sc' or 'Garmin 66sr'
     */
    model: string;

    /**
     * Single-band: false, multi-band: true
     */
    multiBandEnabled: boolean;

    /**
     * GPS only: false, GPS+others: true
     * Other constellations include:
     * * GLONASS (64sc + 66sr)
     * * GALILEO (64sc + 66sr)
     * * QZSS (66sr)
     * * IRNSS (66sr)
     */
    multiGNSSEnabled: boolean;

    /**
     * Use Wide Area Augmentation System/European Geostationary Navigation
     * Overlay Service (WAAS/EGNOS) data.
     * WAAS/EGNOS is not available on the multi-band Garmin GPSMAP 66sr.
     */
    waasEgnosEnabled: boolean;
}

/** Default GPS configuration when no details are provided in the JSON file. */
const defaultGpsConfig = [
    {
        model: "Garmin 64sc",
        multiBandEnabled: false,
        multiGNSSEnabled: true,
        waasEgnosEnabled: false,
    },
];

/** Structure of the JSON file. */
export interface StoryInfo {
    /** Start date in the YYYY-MM-DD format. */
    start?: string;

    /** Trip duration in days. Can be half. */
    duration?: number;

    /**
     * The meteorological season, which depend not only on the start date,
     * but also the hemisphere.
     */
    season?: SeasonStrings;

    /** True if there is a WebTrack to load. */
    hasGeodata?: boolean;

    /** The theme used for the map if the story has geodata. */
    mapTheme?: MapThemeStrings;

    /**
     * Photo folder name of the latest photo taken on that trip.
     * Value automatically generated by the Webpack plugin.
     */
    mostRecentPhoto?: number;

    /**
     * GPS model and configuration. Such information is not included in the
     * GPX file, therefore not included in the WebTrack metadata.
     * This config is skipped if hasGeodata is false.
     */
    gpsConfig?: GpsConfig[];

    /**
     * Total number of photos linked to this story. Minimum: 1.
     * Value automatically generated by the Webpack plugin.
     */
    totalPhotos: number;

    /**
     * List of geocoded photos linked to the story.
     * Value automatically generated by the Webpack plugin.
     */
    geocodedPhotos: GeocodedPhoto[];
}

/** Based on the Markdown file. */
export interface ProcessedStoryFile {
    title: string | null;
    content: string | null;
}

/**
 * Process a TRUSTED story file and return the title separated from the content.
 */
function mdProcessor(text: string): ProcessedStoryFile {
    let blocks = text.trim().split(/(?:\r?\n){2,}/);

    // the story title is excluded from the content
    const titleWords = blocks[0].split(/\r?\n/)[0].split(" ");
    if (titleWords[0] !== "#") {
        return { title: null, content: null };
    }

    titleWords.shift(); // remove the hashtag
    blocks.shift(); // remove the story title

    blocks = blocks.map((l) =>
        [" ", "\t", "#", "-", "*"].some((ch) => l.startsWith(ch))
            ? snarkdown(l)
            : `<p>${snarkdown(l)}</p>`,
    );

    return {
        title: titleWords.join(" "),
        content: blocks.join(""),
    };
}

function getOriginPhotoId(): number | null {
    const id = parseInt(
        String(m.parsePathname(m.route.get()).params.from_photo),
    );
    return isNaN(id) || id > config.firstPhotoId ? null : id;
}

/**
 * Model handling one story.
 * @notExported
 */
export class Story {
    /** Story title retrieved from the Markdown file. */
    title: string | null = null;

    /** Story content (without title) retrieved from the Markdown file. */
    content: string | null = null;

    /** Start date retrieved from the JSON file. */
    start: EasyDate | null = null;

    /** Total number of days, retrieved from the JSON file. */
    duration: number | null = null;

    /** Local season retrieved from the JSON file. */
    season: SeasonStrings | null = null;

    /** True if the story contains a WebTrack, based on the JSON file. */
    hasGeodata = false;

    /** The map theme used if the story has geodata. */
    mapTheme: MapThemeStrings = "default";

    /** The most recent photo ID of the story, based on the JSON file. */
    mostRecentPhoto: number | null = null;

    /** GPS model and configuration, based on the JSON file or default conf. */
    gpsConfig: GpsConfig[] | null = null;

    /** Folder name of the story. */
    folderName: string | null = null;

    /** True if the story title and content has been fetched and processed. */
    gotContent = false;

    /** True if the JSON file has been fetched and processed. */
    gotStoryMeta = false;

    /** JSON file of the linked photo. */
    originPhotoMeta: PhotoInfo | null = null;

    /** List of geocoded photos linked to the story. */
    geocodedPhotos: GeocodedPhoto[] | null = null;

    /** True if fetching the story metadata returned 404. */
    notFound = false;

    /** True when the data source information are expanded/visible. */
    isDataSourceExpanded = false;

    /** True if a story is available. */
    isLoaded(): boolean {
        return this.gotContent && this.gotStoryMeta;
    }

    /** Static method converting a string date like 2020-10-25. */
    static strToEasyDate(strDate: string | undefined): EasyDate | null {
        if (!strDate) {
            return null;
        }
        try {
            const [year, month, day] = strDate.split("-");
            return {
                day: parseInt(day),
                month: parseInt(month),
                year: parseInt(year),
            };
        } catch {
            return null;
        }
    }

    /** Static method fetching the story title and content. */
    static getStoryTitleContent(
        folderName: string,
    ): Promise<ProcessedStoryFile> {
        return new Promise((resolve, reject) => {
            m.request<ProcessedStoryFile>({
                method: "GET",
                url: "/content/stories/:folderName/:lang.md",
                params: {
                    folderName,
                    lang: t.getLang(),
                },
                headers: {
                    "Content-Type": "text/markdown; charset=utf-8",
                    Accept: "text/*",
                },
                // use 'extract' because 'deserialize' gives a null string
                extract: (xhr) => {
                    if (xhr.status === 200) {
                        return mdProcessor(xhr.responseText);
                    } else {
                        return { title: null, content: null };
                    }
                },
            })
                .then((result) => {
                    if (!result.title || !result.content) {
                        reject(new Error("Missing title or content"));
                    }
                    resolve(result);
                })
                .catch(reject);
        });
    }

    /** Get the photo ID from the URL, otherwise from the story metadata. */
    getActualPhotoId(): number | null {
        return getOriginPhotoId() || this.mostRecentPhoto;
    }

    /**
     * The origin photo ID is provided by the URL parameter. If not found, it
     * would be the default photo of the story based on the metadata file.
     * Load the origin photo metadata to be asynchronously inserted in the
     * story page.
     */
    loadOriginPhotoMeta(): void {
        const originPhotoId = this.getActualPhotoId();
        if (!originPhotoId) {
            return;
        }
        m.request<PhotoInfo>({
            method: "GET",
            url: "/content/photos/:folderName/_/i.json",
            params: { folderName: originPhotoId },
        }).then((result) => {
            this.originPhotoMeta = result;
        });
    }

    /** Load the story identified by its ID, or do nothing if not existing. */
    reload(): void {
        if (this.folderName) {
            this.load(this.folderName);
        }
    }

    /** Load a story from a specific folder (fields are null if not found). */
    load(folderName: string): void {
        this.notFound = false;
        this.gotContent = false;
        this.gotStoryMeta = false;
        this.originPhotoMeta = null;
        this.geocodedPhotos = null;
        this.folderName = folderName;
        Story.getStoryTitleContent(folderName)
            .then((result) => {
                this.title = result.title;
                this.content = result.content;
                this.gotContent = true;
            })
            .catch(() => {
                m.route.set(
                    `/${t.getLang()}/lost`,
                    {},
                    {
                        replace: true,
                    },
                );
            });
        m.request<StoryInfo>({
            method: "GET",
            url: "/content/stories/:folderName/_/i.json",
            params: { folderName },
        })
            .then((result) => {
                if (result.start) {
                    this.start = Story.strToEasyDate(result.start);
                } else {
                    this.start = null;
                }
                if (result.season !== undefined) {
                    if (Season[result.season] !== undefined) {
                        this.season = result.season;
                    } else {
                        error.log(`Unknown season '${String(result.season)}'`);
                        this.season = null;
                    }
                } else {
                    this.season = null;
                }
                this.duration = result.duration ?? null;
                this.hasGeodata = result.hasGeodata ?? false;
                this.mostRecentPhoto = result.mostRecentPhoto ?? null;
                this.geocodedPhotos = result.geocodedPhotos ?? null;
                if (this.hasGeodata) {
                    this.gpsConfig = result.gpsConfig ?? defaultGpsConfig;
                } else {
                    this.gpsConfig = null;
                }
                if (result.mapTheme && MapTheme[result.mapTheme]) {
                    this.mapTheme = result.mapTheme;
                } else {
                    this.mapTheme = "default";
                }
                this.gotStoryMeta = true;
                this.loadOriginPhotoMeta();
            })
            .catch((error: Error & { code: number }) => {
                if (error.code === 404) {
                    this.notFound = true;
                }
                this.start = null;
                this.gotStoryMeta = true;
                this.hasGeodata = false;
            });
    }

    /** Path to the photo of the loaded story. */
    getPhotoPath(): string | null {
        const originPhoto = this.getActualPhotoId();
        if (!originPhoto) {
            return null;
        }
        return m.buildPathname("/:lang/photo/:id", {
            lang: t.getLang(),
            id: originPhoto,
        });
    }
}

/** This is a shared instance. */
export const story = new Story();
